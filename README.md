# Python_Test

## 출제 빈도가 높은 알고리즘 유형
* 그리디(쉬운 난이도)
* 구현
* DFS/BFS를 활용한 탐색

## 알고리즘 성능 평가
### 복잡도(Complexity)
* 복잡도는 알고리즘의 성능을 나타내는 척도이다.
  * 시간 복잡도 : 특정한 크기의 입력에 대하여 알고리즘의 수행 시간 분석
  * 공간 복잡도 : 특정한 크기의 입력에 대하여 알고리즘의 메모리 사용량 분석
* 동일한 기능을 수행하는 알고리즘이 있다면, 일반적으로 복잡도가 낮을수록 좋은 알고리즘이다.
  * 시간 복잡도가 높다 : 수행시간 측면에서 더 많은 시간이 소요될 수 있다.
  * 공간 복잡도가 높다 : 많은 메모리가 필요하다.


### 빅오 표기법(Big-O Notation)
* 가장 빠르게 증가하는 항만을 고려하는 표기법
* 때문에, 함수의 상한만을 나타내게 되는 특징을 가진다.

#### 시간 복잡도 계산해보기 1)
```python
array = [3, 5, 1, 2, 4] # 5개의 데이터 (N=5)
sum = 0 # 합계를 저장할 변수

# 모든 데이터를 하나씩 확인하며 합계를 계산
for x in array:
  sum += x
```
* 수행 시간은 데이터의 개수 N에 비례할 것임을 예측할 수 있다.
  * 시간 복잡도 : O(N)


#### 시간 복잡도 계산해보기 2)
* 2중 반복문을 이용하는 프로그램 예제
```python
array = [3, 5, 1, 2, 4] # 5개의 데이터 (N=5)

for i in array:
  for j in array:
    temp = i * j
    print(temp)
```
* 시간 복잡도 O(N^2)

#### 요구사항에 따라 적절한 알고리즘 설계하기
* 문제에서 가장 먼저 확인해야 하는 내용은 시간제한(수행시간 요구사항) 이다.

## 알고리즘 문제 해결 과정
* 일반적인 알고리즘 문제 해결 과정은 다음과 같다.
  * 1. 지문 읽기 및 컴퓨터적 사고
  * 2. 요구사항(복잡도) 분석 @중요!
  * 3. 문제 해결을 위한 아이디어 찾기
  * 4. 소스코드 설계 및 코딩

* 일반적으로 대부분의 문제 출제자들은 핵심 아이디어를 캐치한다면, 간결하게 소스코드를 작성할 수 있는 형태로 문제를 출제한다.
